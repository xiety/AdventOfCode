using System.CodeDom.Compiler;
using System.Collections.Immutable;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Advent.Analyzers;

[Generator]
public sealed class RegexWrapperGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var methods = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is MethodDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) => GetMethodInfo(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(methods.Collect()),
            static (spc, tuple) => Execute(spc, tuple.Right));
    }

    sealed record Model(string Method, string Target, string Class, string? Ns, bool CanBeNull);

    static Model? GetMethodInfo(GeneratorSyntaxContext ctx)
    {
        var method = (MethodDeclarationSyntax)ctx.Node;
        var symbol = ctx.SemanticModel.GetDeclaredSymbol(method) as IMethodSymbol;
        if (symbol is not { IsStatic: true })
            return null;

        var attr = symbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass is
            {
                Name: "MapToAttribute",
                IsGenericType: true,
                TypeArguments.Length: > 0
            });

        if (attr?.AttributeClass is not { } attrClass)
            return null;

        var ns = symbol.ContainingType.ContainingNamespace.IsGlobalNamespace
            ? null
            : symbol.ContainingType.ContainingNamespace.ToDisplayString();

        var target = attrClass.TypeArguments[0];
        var canBeNull = target.IsReferenceType || IsNullableValueType(target);

        return new Model(
            symbol.Name,
            target.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            symbol.ContainingType.Name,
            ns,
            canBeNull);
    }

    static void Execute(SourceProductionContext spc, ImmutableArray<Model?> methods)
    {
        if (methods.IsDefaultOrEmpty)
            return;

        var ordered = methods
            .Select(m => m!)
            .OrderBy(m => m.Ns ?? string.Empty)
            .ThenBy(m => m.Class)
            .GroupBy(m => (m.Ns, m.Class));

        using var sw = new StringWriter();
        using var w = new IndentedTextWriter(sw);

        w.WriteLine("// <auto-generated/>");
        w.WriteLine("#nullable enable");
        w.WriteLine("using System.Text.RegularExpressions;");
        w.WriteLine("using System.Diagnostics.CodeAnalysis;");
        w.WriteLine();

        foreach (var g in ordered)
        {
            var (ns, className) = g.Key;

            if (!string.IsNullOrEmpty(ns))
            {
                w.WriteLine($"namespace {ns}");
                w.WriteLine("{");
                w.Indent++;
            }

            w.WriteLine($"static partial class {className}");
            w.WriteLine("{");
            w.Indent++;

            foreach (var m in g)
            {
                var suffix = m.CanBeNull ? "?" : string.Empty;

                w.WriteIndentedRaw($"""
                    public static bool TryMapTo{m.Method}(string input, [NotNullWhen(true)] out {m.Target}{suffix} result)
                        => {m.Method}().TryMapTo<{m.Target}>(input, out result);

                    public static {m.Target} MapTo{m.Method}(string input)
                        => {m.Method}().MapTo<{m.Target}>(input);

                    public static {m.Target}[] FromLines{m.Method}(System.Collections.Generic.IEnumerable<string> lines)
                        => {m.Method}().FromLines<{m.Target}>(lines);

                    """);
            }

            w.Indent--;
            w.WriteLine("}");

            if (!string.IsNullOrEmpty(ns))
            {
                w.Indent--;
                w.WriteLine("}");
                w.WriteLine();
            }
        }

        spc.AddSource("RegexWrappers.g.cs", sw.ToString());
    }

    static bool IsNullableValueType(ITypeSymbol type)
        => type.IsValueType && type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T;
}
