using System.CodeDom.Compiler;
using System.Collections.Immutable;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Advent.Analyzers;

[Generator]
public class TestGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var methods = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is MethodDeclarationSyntax m && m.AttributeLists.Count > 0,
                transform: static (ctx, _) => GetMethodContext(ctx))
            .Where(static m => m != null);

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(methods.Collect()),
            static (spc, tuple) => Emit(spc, tuple.Right));
    }

    private sealed record MethodData(
        MethodDeclarationSyntax Syntax,
        IMethodSymbol Symbol,
        string Sample,
        string Input,
        bool IsPartA,
        string Ns,
        string Class);

    private static MethodData? GetMethodContext(GeneratorSyntaxContext ctx)
    {
        var decl = (MethodDeclarationSyntax)ctx.Node;
        var symbol = ctx.SemanticModel.GetDeclaredSymbol(decl);
        if (symbol is null)
            return null;

        var attr = symbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name.StartsWith("GeneratedTest") == true);
        if (attr is null)
            return null;

        var sample = attr.ConstructorArguments[0].ToCSharpString();
        var input = attr.ConstructorArguments[1].ToCSharpString();
        var isA = symbol.Name.StartsWith("RunA", StringComparison.OrdinalIgnoreCase);
        var ns = symbol.ContainingType.ContainingNamespace.IsGlobalNamespace
            ? string.Empty
            : symbol.ContainingType.ContainingNamespace.ToDisplayString();
        var cls = symbol.ContainingType.Name;

        return new MethodData(decl, symbol, sample, input, isA, ns, cls);
    }

    private static void Emit(SourceProductionContext spc, ImmutableArray<MethodData?> methods)
    {
        if (methods.IsDefaultOrEmpty)
            return;

        var ordered = methods
            .Select(m => m!)
            .OrderBy(m => m.Ns)
            .ThenBy(m => m.Class)
            .GroupBy(m => (m.Ns, m.Class));

        using var sw = new StringWriter();
        using var w = new IndentedTextWriter(sw);

        w.WriteLine("// <auto-generated/>");
        w.WriteLine("#nullable enable");
        w.WriteLine("using Microsoft.VisualStudio.TestTools.UnitTesting;");
        w.WriteLine("using Advent.Common;");
        w.WriteLine();

        foreach (var g in ordered)
        {
            var (ns, className) = g.Key;
            var testName = ns.Split('.').LastOrDefault() ?? className;

            if (!string.IsNullOrEmpty(ns))
            {
                w.WriteLine($"namespace {ns}.Tests");
                w.WriteLine("{");
                w.Indent++;
            }

            w.WriteLine("[TestClass]");
            w.WriteLine($"public partial class {testName} : GeneratedTestBase");
            w.WriteLine("{");

            foreach (var m in g.OrderBy(x => x.Symbol.Name))
            {
                w.Indent++;
                w.WriteIndentedRaw(GenerateTests(m, m.Symbol.ContainingType));
                w.Indent--;
            }

            w.WriteLine("}");
            w.WriteLine();

            if (!string.IsNullOrEmpty(ns))
            {
                w.Indent--;
                w.WriteLine("}");
                w.WriteLine();
            }
        }

        spc.AddSource("GeneratedTests.g.cs", sw.ToString());
    }

    private static string GenerateTests(MethodData m, INamedTypeSymbol solver)
    {
        var sourcePath = m.Syntax.SyntaxTree.FilePath.Replace(@"\", @"\\");
        var line = m.Syntax.GetLocation().GetLineSpan().StartLinePosition.Line + 1;
        var displayPath = m.Syntax.SyntaxTree.FilePath ?? "";
        var hasBool = m.Symbol.Parameters.Length == 2;
        var className = solver.ToDisplayString();

        string Test(bool sample) => $$"""
            #line {{line}} "{{displayPath}}"
            [TestMethod]
            public void {{m.Symbol.Name}}_{{(sample ? "Sample" : "Input")}}()
            {
                var lines = LoadInput(@"{{sourcePath}}", {{m.IsPartA.ToString().ToLower()}}, {{sample.ToString().ToLower()}});
                {{(m.Symbol.IsStatic ? "" : $"var solver = new {className}();")}}
                var actual = {{(m.Symbol.IsStatic ? $"{className}.{m.Symbol.Name}" : $"solver.{m.Symbol.Name}")}}({{(hasBool ? $"lines, {sample.ToString().ToLower()}" : "lines")}});
                Assert.AreEqual({{(sample ? m.Sample : m.Input)}}, actual);
            }
            #line default

            """;

        return Test(true) + "\n" + Test(false);
    }
}
